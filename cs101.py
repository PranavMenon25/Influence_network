# -*- coding: utf-8 -*-
"""CS101

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aRoLxSEHCakjY-d_0Thglc0CBEsE02PD
"""

import numpy as np
import networkx as nx
import pandas as pd
import math
import matplotlib.pyplot as plt
import random

df = pd.read_excel('Data.xlsx')
G = nx.DiGraph()
for index, row in df.iterrows():
    row_list = row.tolist()
    t = row_list[1]
    t = t[:11].lower()
    for i in range(2, 31):
        if(not isinstance(row_list[i], str)):
           continue
        x = row_list[i]
        x = x[-11:]
        x = x.lower()
        G.add_edge(t, x)

nx.draw(G, with_labels=True, node_color='red')
plt.show()

G.number_of_nodes()

all_nodes = list(G.nodes())
print(all_nodes)
node_to_begin = random.choice(all_nodes)
print(node_to_begin)

rand_walk = [0 for p in range(G.number_of_nodes())]

number = ["" for p in range(143)]

for i in range(143):
    number[i] = all_nodes[i]

"""# Question 1"""

for i in range(143):
    if(number[i] == node_to_begin):
        rand_walk[i] = rand_walk[i] + 1
        break

print(rand_walk)

all_nodes = list(G.nodes())
nodes = len(all_nodes)
rand_walk = [0 for _ in range(nodes)]  # Initialize points with zeros
current_node = random.choice(all_nodes)
for i in range(143):
  if(all_nodes[i] == current_node):
    rand_walk[i] += 1

for i in range(1000000):
  out_edges = list(G.out_edges(current_node))  # Get the out edges of the current node
  if len(out_edges) == 0:
    next_node = random.choice(all_nodes)
  else:
    random_edge = list(random.choice(out_edges))  # Randomly select an out edge
    next_node = random_edge[1]  # Get the target node of the selected edge
    for i in range(143):
      if(all_nodes[i] == next_node):
        rand_walk[i] += 1
  current_node = next_node  # Update the current node for the next iteration

max = 0
val = 0
print(rand_walk)
for i in range(143):
    if(rand_walk[i]>val):
        max = i
        val = rand_walk[i]
print(number[max])

"""# Question 2"""

matrix = nx.to_numpy_array(G)

matrix

for i in range(143):
    for j in range(143):
        if(matrix[i][j] == matrix[j][i] and matrix[i][j] == 0 and i!=j):
            matrix[i][j] = -1
            matrix[j][i] = -1

matrix

all_nodes = list(G.nodes())
p = 0
for i in range(0, 143):
    if(matrix[0][i] == 1 or matrix[0][i] == 0):
#         print(p)
        for j in range(143):
            temp = matrix[j][i]
            matrix[j][i] = matrix[j][p]
            matrix[j][p] = temp
#         print(p)
        for j in range(143):
            temp = matrix[i][j]
            matrix[i][j] = matrix[p][j]
            matrix[p][j] = temp
            temp = all_nodes[i]
            all_nodes[i] = all_nodes[p]
            all_nodes[p] = temp
        p += 1
# print(matrix)

def swap_rows(i, p):
  for j in range(143):
    temp = matrix[j][i]
    matrix[j][i] = matrix[j][p]
    matrix[j][p] = temp
#         print(p)
  for j in range(143):
    temp = matrix[i][j]
    matrix[i][j] = matrix[p][j]
    matrix[p][j] = temp

matrix

swap_rows(2,3)
swap_rows(3,6)

matrix

def find_link(i, j):
  try:
    # print("A")
    A = matrix[:i-1, :j-1]
    B = matrix[i, :j-1]
    # print(A, B)
    C = np.transpose(A)

    # Ax = b
    x = np.linalg.lstsq(C, B, rcond=None)[0]
    x = x.reshape(-1, 1)
    M = matrix[:i-1, j]
    M = M.reshape(-1, 1)
    final = np.dot(M.T, x)
    # print(final)
    if(final > 0):
      return 1
    else:
      return 0
  except np.linalg.LinAlgError as e:
    return 0

# import sys
# with open('output.txt', 'w') as f:
#     sys.stdout = f
#     one = 0
#     zero = 0
#     for i in range(143):
#       for j in range(143):
#         if(i != j):
#           if(matrix[i,j] == -1):
#             matrix[i, j] = find_link(i, j)
#             if(matrix[i][j] == 0):
#               zero += 1
#             elif(matrix[i][j] == 1):
#               print(all_nodes[i], " --> ", all_nodes[j])
#               one += 1
#             pass

#     print(zero, " ", one)
#     sys.stdout = sys.__stdout__

"""# Question 3

"""

matrix = nx.to_numpy_array(G)
total = 0
total_impr = 0
for i in range(143):
  for j in range(143):
    if(matrix[i,j] == matrix[j,i] and matrix[i,j] == 1):
      total += 1
    if(matrix[i,j] == 1):
      total_impr += 1
print(total_impr, " ", total)

# One of the things is to find unusual nodes:
# indegree and outdegree
in_degree = dict(G.in_degree())
out_degree = dict(G.out_degree())

in_degree = {node: int(degree) for node, degree in in_degree.items()}
out_degree = {node: int(degree) for node, degree in out_degree.items()}

unusual_difference = [(node, abs(in_deg - out_degree[node])) for node, in_deg in in_degree.items() if abs(in_deg - out_degree[node]) > 25]

if unusual_difference:
    for node, difference in unusual_difference:
        print(node, " ", difference)
else:
    print("None of the nodes were found")

# Dead end... -> Information goes lost
# The nodes which have no out-degree. Or these people were the least impressionable
for i in out_degree.items():
  if i[1] == 0:
    print(i)

# Influential sumbit
out = in_degree.items()
out = sorted(out, key = lambda out: out[1], reverse=True)
out
out[0:5]

from collections import deque
broke = 0
path_ = 0
total = 0
for i in range(10000):
  path = 0
  A = random.choice(all_nodes)
  B = random.choice(all_nodes)
  # print(A, " ", B)
  visited = set()
  queue = deque([(A, 0)])
  flag = 0
  i = 0
  for i in range(1000):
    # print(queue)
    if queue:
      current_node, last_dist = queue.popleft()
      # print(last_dist)
      # print(current_node)
      if current_node == B:
        # print("Found at distance:", last_dist)
        path_ += last_dist
        total+=1
        break
      if current_node not in visited:
        visited.add(current_node)
        if flag == 0:
          flag = 1
          for node in G[current_node]:
            if node not in visited:
              queue.append((node, last_dist + 1))
        else:
          out_edges = list(G.out_edges(current_node))
          if len(out_edges) == 0:
            continue
          else:
            random_edge = random.choice(out_edges)
            next_node = random_edge[1]
            if next_node not in visited:
              # print(next_node)
              queue.append((next_node, last_dist + 1))
            random_edge = random.choice(out_edges)
            next_node = random_edge[1]
            if next_node not in visited:
              queue.append((next_node, last_dist+1))
            random_edge = random.choice(out_edges)
            next_node = random_edge[1]
            if next_node not in visited:
              queue.append((next_node, last_dist+1))
            random_edge = random.choice(out_edges)
            next_node = random_edge[1]
            if next_node not in visited:
              queue.append((next_node, last_dist+1))
    else:
      # print("Broke due to empty queue")
      broke += 1
      break
  # print(i)

print("It broke : ", broke, " number of time and the average distance between two nodes was : ", (path_/total))
print(total)
print(path_)

# Going a step further:
# Election
from collections import deque
broke = 0
path_ = 0
total = 0
for i in range(10000):
  path = 0
  A = random.choice(all_nodes)
  B = random.choice(all_nodes)
  # print(A, " ", B)
  visited = set()
  queue = deque([(A, 0)])
  flag = 0
  i = 0
  for i in range(1000):
    # print(queue)
    if queue:
      current_node, last_dist = queue.popleft()
      # print(last_dist)
      # print(current_node)
      if current_node not in visited:
        visited.add(current_node)
        if flag == 0:
          flag = 1
          for node in G[current_node]:
            if node not in visited:
              queue.append((node, last_dist + 1))
        else:
          out_edges = list(G.out_edges(current_node))
          if len(out_edges) == 0:
            continue
          else:
            random_prob = random.random()
            total_nodes = len(out_edges) * random_prob
            total_nodes = int(total_nodes)

            for i in range(total_nodes):
              random_edge = random.choice(out_edges)
              next_node = random_edge[1]
              if next_node not in visited:
                queue.append((next_node, last_dist+1))
    else:
      # print("Broke due to empty queue")
      path_ += len(visited)
      # print(path_)
      broke += 1
      break
  # print(i)
path_ = path_/10000
print(path_)
print("The percentage of nodes left", (143-path_)*(100/143))

